ft_memset:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_bzero:      [OK] [OK] [OK] [OK] 
ft_memcpy:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memccpy:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memmove:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memcmp:     [OK] [OK] [FAILED] [FAILED] [FAILED] [FAILED] [FAILED] [OK] [NO CRASH] [NO CRASH] 
[fail]: your memcmp does not work with basic input
Test code:
	char *s1 = "\xff\xaa\xde\x12";
	char *s2 = "\xff\xaa\xde\x12MACOSAAAAA";
	size_t size = 4;
	int i1 = simple_memcmp(s1, s2, size);
	int i2 = ft_memcmp(s1, s2, size);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
      memcmp: |0|
   ft_memcmp: |-5|

[fail]: your memcmp does not work with basic input
Test code:
	char *s1 = "\xff\xaa\xde\xffMACOSX\xff";
	char *s2 = "\xff\xaa\xde\x02";
	size_t size = 8;
	int i1 = simple_memcmp(s1, s2, size);
	int i2 = ft_memcmp(s1, s2, size);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
      memcmp: |253|
   ft_memcmp: |-12|

[fail]: your memcmp does not cast the memory in unsigned char
Test code:
	char *s1 = "\xff\xaa\xde\200";
	char *s2 = "\xff\xaa\xde\0";
	size_t size = 8;
	int i1 = simple_memcmp(s1, s2, size);
	int i2 = ft_memcmp(s1, s2, size);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
      memcmp: |128|
   ft_memcmp: |-190519|

[fail]: your memcmp stop at \0
Test code:
	char *s1 = "atoms\0\0\0\0";
	char *s2 = "atoms\0abc";
	size_t size = 8;
	int i1 = simple_memcmp(s1, s2, size);
	int i2 = ft_memcmp(s1, s2, size);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
      memcmp: |-97|
   ft_memcmp: |-10|

[fail]: your memcmp does not work with basic input
Test code:
	char *s1 = "\xff\0\0\xaa\0\xde\xffMACOSX\xff";
	char *s2 = "\xff\0\0\xaa\0\xde\x00MBS";
	size_t size = 9;
	int i1 = simple_memcmp(s1, s2, size);
	int i2 = ft_memcmp(s1, s2, size);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
      memcmp: |255|
   ft_memcmp: |-15|

[no crash]: your memcmp does not segfault when null parameter is sent
Test code:
	char b1[] = "nyancat";

	ft_memcmp(((void *)0), b1, 4);


[no crash]: your memcmp does not segfault when null parameter is sent
Test code:
	char b1[] = "nyancat";

	ft_memcmp(b1, ((void *)0), 4);


ft_strlen:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strdup:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strcpy:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strncpy:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strcat:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strncat:    [FAILED] [OK] [FAILED] [FAILED] [FAILED] [OK] [FAILED] [FAILED] [CRASH] [OK] [OK] 
[fail]: your strncat does not work with basic input
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00] = "there is no stars in the sky";
	char buff2[0xF00] = "there is no stars in the sky";
	size_t max = 5;

	__builtin___strncat_chk (buff1, str, max, __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	ft_strncat(buff2, str, max);
	if (!strcmp(buff1, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strncat: |there is no stars in the skythe c|
  ft_strncat: |there is no stars in the sky|

[fail]: your strncat does not work with basic input
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00] = "there is no stars in the sky";
	char buff2[0xF00] = "there is no stars in the sky";
	size_t max = 5;

	__builtin___strncat_chk (buff1, str, max, __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	ft_strncat(buff2, str, max);
	if (!strcmp(buff1, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strncat: |there is no stars in the skythe c|
  ft_strncat: |there is no stars in the sky|

[fail]: your strncat does not work with over length size
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00] = "there is no stars in the sky";
	char buff2[0xF00] = "there is no stars in the sky";
	size_t max = 1000;

	__builtin___strncat_chk (buff1, str, max, __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	ft_strncat(buff2, str, max);
	if (!strcmp(buff1, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strncat: |there is no stars in the skythe cake is a lie !|
  ft_strncat: |there is no stars in the sky|

[fail]: your strncat does not work with unicode string
Test code:
	char *str = "ã“ã‚“ã«ã¡ã¯";
	char buff1[0xF00] = "ã“ã‚“ã«ã¡ã¯";
	char buff2[0xF00] = "ã“ã‚“ã«ã¡ã¯";
	size_t max = 1000;

	__builtin___strncat_chk (buff1, str, max, __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	ft_strncat(buff2, str, max);
	if (!strcmp(buff1, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strncat: |ã“ã‚“ã«ã¡ã¯ã“ã‚“ã«ã¡ã¯|
  ft_strncat: |ã“ã‚“ã«ã¡ã¯|

[fail]: your strcat does not work with empty string as second parameter
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00] = "";
	char buff2[0xF00] = "";
	size_t max = 5;

	__builtin___strncat_chk (buff1, str, max, __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	ft_strncat(buff2, str, max);
	if (!strcmp(buff1, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strncat: |the c|
  ft_strncat: ||

[fail]: your strncat does not set a \0 to the end
Test code:
	char *str = "n\0AAAAAAAAAAAAAAAAA";
	char buff1[0xF00] = "\0AAAAAAAAAAAAAAAA";
	char buff2[0xF00] = "\0AAAAAAAAAAAAAAAA";
	size_t max = 10;

	__builtin___strncat_chk (buff1, str, max, __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	ft_strncat(buff2, str, max);
	if (!strcmp(buff1, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strncat: |n|
  ft_strncat: ||

[crash]: your strncat crash cause it read too many bytes or attempt to write on buff !
Test code:
	const size_t size = 10;
	char *str = electric_alloc(size);
	char *buff = electric_alloc(size);

	__builtin___strcpy_chk (buff, "AB", __builtin_object_size (buff, 2 > 1 ? 1 : 0));
	__builtin___strcpy_chk (str, "CDEFGHI", __builtin_object_size (str, 2 > 1 ? 1 : 0));
	ft_strncat(buff, str, 10);
	exit(TEST_SUCCESS);


ft_strlcat:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strrchr:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strstr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strnstr:    [FAILED] [OK] [FAILED] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
[fail]: your strnstr does not work with basic input
Test code:
	char *s1 = "see FF your FF return FF now FF";
	char *s2 = "FF";
	size_t max = strlen(s1);
	char *i1 = strnstr(s1, s2, max);
	char *i2 = ft_strnstr(s1, s2, max);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strnstr: |FF your FF return FF now FF|
  ft_strnstr: |(null)|

[fail]: your strnstr does not work with basic input
Test code:
	char *s1 = "MZIRIBMZIRIBMZE123";
	char *s2 = "MZIRIBMZE";
	size_t max = strlen(s2);
	char *i1 = strnstr(s1, s2, max);
	char *i2 = ft_strnstr(s1, s2, max);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strnstr: |(null)|
  ft_strnstr: |MZIRIBMZE123|

ft_strcmp:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strncmp:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_atoi:       [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [KO] [KO] [NO CRASH] 
[KO]: your atoi does not work with over long max value
Test code:
	char n[40] = "99999999999999999999999999";
	int i1 = atoi(n);
	int i2 = ft_atoi(n);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        atoi: |-1|
     ft_atoi: |-469762049|

[KO]: your atoi does not work with over long min value
Test code:
	char n[40] = "-99999999999999999999999999";
	int i1 = atoi(n);
	int i2 = ft_atoi(n);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        atoi: |0|
     ft_atoi: |469762049|

[no crash]: your atoi does not work with over long min value
Test code:
	ft_atoi(((void *)0));


ft_isalpha:    [OK] 
ft_isdigit:    [OK] 
ft_isalnum:    [OK] 
ft_isascii:    [OK] 
ft_isprint:    [OK] 
ft_toupper:    [OK] 
ft_tolower:    [OK] 
ft_memalloc:   [OK] [OK] [OK] [OK] [OK] 
ft_memdel:     [OK] [OK] {protected}
ft_strnew:     [OK] [FAILED] [OK] [OK] 
[fail]: your strnew does not set allocated mem to 0
Test code:
	size_t size = 514;

	char *ret = ft_strnew(size);
	for (size_t i = 0;i < size + 1;i++)
		if (ret[i] != 0)
		{
			exit(TEST_FAILED);
		}
		free(ret);
		exit(TEST_SUCCESS);

Diffs:
      strnew: |0|
   ft_strnew: |65|

ft_strdel:     [OK] [OK] {protected}
ft_strclr:     [OK] {protected}
ft_striter:    [OK] [OK] {protected}
ft_striteri:   [OK] [OK] {protected}
ft_strmap:     [OK] [FAILED] [FAILED] [OK] [OK] {protected}
[fail]: your strmap did not set \0 at the end of the string
Test code:
	char *b = "override this !";
	char b2[0xF0];
	size_t size = strlen(b);

	for (size_t i = 0; i < size; i++)
		b2[i] = f_strmap(b[i]);
	b2[size] = 0;
	char *ret = ft_strmap(b, f_strmap);
	if (!memcmp(b2, ret, size + 1))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
      strmap: |v}lyypkl'{opz'(|
   ft_strmap: |v}lyypkl'{opz'(A|

[fail]: your strmap does not malloc ?
Test code:
	char *b = "override this !";
	char b2[0xF0];
	size_t size = strlen(b);

	for (size_t i = 0; i < size; i++)
		b2[i] = f_strmap(b[i]);
	b2[size] = 0;
	fd_to_buffer(1);
	char *newstr = ft_strmap(b, f_strmap);
	if (!strcmp(newstr, b2))
		exit(TEST_SUCCESS);
	free(newstr);
	write(1, "", 1);
	write(1, "", 1);
	get_fd_buffer(1, ((void *)0), 0);
	exit(TEST_FAILED);

Diffs:
      strmap: |v}lyypkl'{opz'(|
   ft_strmap: |v}lyypkl'{opz'(@TœÔJÿ|

ft_strmapi:    [FAILED] [OK] [FAILED] [OK] [OK] {protected}
[fail]: your strmapi does not work
Test code:
	char *b = "override this !";
	char b2[0xF0];
	size_t size = strlen(b);

	for (size_t i = 0; i < size; i++)
		b2[i] = f_strmapi(i, b[i]);
	b2[size] = 0;
	char *ret = ft_strmapi(b, f_strmapi);
	if (!strcmp(b2, ret))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strmapi: |owguvnjl(}rt-/@      strmap: |v}lyypkl'{opz'(|
   ft_strmap: |v}lyypkl'{opz'(@TœÔJÿ||
  ft_strmapi: |owguvnjl(}rt-/|

[fail]: your strmapi did not set \0 at the end of the string
Test code:
	char *b = "override this !";
	char b2[0xF0];
	size_t size = strlen(b);

	for (size_t i = 0; i < size; i++)
		b2[i] = f_strmapi(i, b[i]);
	b2[size] = 0;
	char *ret = ft_strmapi(b, f_strmapi);
	if (!memcmp(b2, ret, size + 1))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strmapi: |owguvnjl(}rt-/ATœÔJÿ|
  ft_strmapi: |owguvnjl(}rt-/|

ft_strequ:     [OK] [OK] [OK] [OK] {protected}
ft_strnequ:    [OK] [OK] [OK] [OK] {protected}
ft_strsub:     [OK] [OK] [OK] [FAILED] [FAILED] [OK] [OK] [OK] {protected}
[fail]: your strsub did not allocate the good size so the \0 test may be false
Test code:
	char *str = "i just want this part #############";
	size_t size = 10;
	int ret_size;

	ft_strsub(str, 5, size);
	ret_size = get_last_malloc_size();
	if ((int)size + 1 == ret_size)
	{
		exit(TEST_SUCCESS);
	}
	exit(TEST_FAILED);

Diffs:
      strsub: |11|
   ft_strsub: |12|

[fail]: your strsub does not set \0 to the end of the string
Test code:
	char str[] = "i just want this part #############";
	size_t size = 20;

	char *ret = ft_strsub(str, 5, size);
	str[size + 5] = 0;
	if (!memcmp(ret, str + 5, size + 1))
	{
		free(ret);
		exit(TEST_SUCCESS);
	}
	free(ret);
	exit(TEST_FAILED);

Diffs:
      strsub: |t want this part ###|
   ft_strsub: |t want this part ###AA|

ft_strjoin:    [OK] [OK] [OK] [OK] [OK] {protected}
ft_strtrim:    [FAILED] [FAILED] [FAILED] [CRASH] [CRASH] [KO] [FAILED] [OK] [FAILED] {protected}
[fail]: your strtrim does not work with basic input
Test code:
	char *s1 = "   \t  \n\n \t\t  \n\n\nHello \t  Please\n Trim me !\n   \n \n \t\t\n  ";
	char *s2 = "Hello \t  Please\n Trim me !";
	char *ret = ft_strtrim(s1);

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strtrim: |Hello 	  Please
 Trim me !|
  ft_strtrim: |ello 	  Please
 Trim mea lie !|
|

[fail]: your strtrim does not work with basic input
Test code:
	char *s1 = "   \t  \n\n \t\t  \n\n\nHello \t  Please\n Trim me !";
	char *s2 = "Hello \t  Please\n Trim me !";
	char *ret = ft_strtrim(s1);

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strtrim: |Hello 	  Please
 Trim me !|
  ft_strtrim: |ello 	  Please
 Trim me sky||

[fail]: your strtrim does not work with basic input
Test code:
	char *s1 = "Hello \t  Please\n Trim me !";
	char *s2 = "Hello \t  Please\n Trim me !";
	char *ret = ft_strtrim(s1);

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strtrim: |Hello 	  Please
 Trim me !|
  ft_strtrim: |ello 	  Please
 Trim me|

[crash]: your strtrim does not work with full blank input
Test code:
	char *s1 = "  \t \t \n   \n\n\n\t";
	char *s2 = "";
	char *ret = ft_strtrim(s1);

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


[crash]: your strtrim does not work with empty input
Test code:
	char *s1 = "";
	char *s2 = "";
	char *ret = ft_strtrim(s1);

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


[KO]: your strtrim did not allocate the good size so the \0 test may be false
Test code:
	char *s1 = "\t   \n\n\n  \n\n\t    Hello \t  Please\n Trim me !\t\t\t\n  \t\t\t\t  ";
	char *s2 = "Hello \t  Please\n Trim me !";
	int r_size = strlen(s2);
	int size;

	ft_strtrim(s1);
	size = get_last_malloc_size();
	if (size == r_size + 1)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
     strtrim: |27|
  ft_strtrim: |24|

[fail]: your strtrim does not allocate memory
Test code:
	char *s1 = "   \t  \n\n \t\t  \n\n\nHello \t  Please\n Trim me !\n   \n \n \t\t\n  ";
	char *s2 = "Hello \t  Please\n Trim me !";
	char *ret = ft_strtrim(s1);

	if (!strcmp(ret, s2))
	{
		free(ret);
		exit(TEST_SUCCESS);
	}
	free(ret);
	exit(TEST_FAILED);

Diffs:
     strtrim: |Hello 	  Please
 Trim me !|
  ft_strtrim: |ello 	  Please
 Trim me|

[fail]: your strtrim does not set \0 to the end of the string
Test code:
	char *s1 = "   \t  \n\n \t\t  \n\n\nHello \t  Please\n Trim me !\n   \n \n \t\t\n  ";
	char *s2 = "Hello \t  Please\n Trim me !";

	char *ret = ft_strtrim(s1);
	if (!strcmp(s2, ret))
	{
		free(ret);
		exit(TEST_SUCCESS);
	}
	free(ret);
	exit(TEST_FAILED);

Diffs:
     strtrim: |Hello 	  Please
 Trim me !|
  ft_strtrim: |ello 	  Please
 Trim meA|

ft_strsplit:   [FAILED] [OK] [OK] [OK] [OK] [OK] [FAILED] [OK] [FAILED] {not protected}
[fail]: your strsplit does not work with basic input
Test code:
	char *string = "      split       this for   me  !       ";
	char **expected = ((char*[6]){"split", "this", "for", "me", "!", ((void *)0)});
	char **result = ft_strsplit(string, ' ');

	split_cmp_array(expected, result);

Diffs:
    strsplit: |`P+ž|
 ft_strsplit: |this|

[fail]: your strsplit does not work with basic input
Test code:
	char *s = "split  ||this|for|me|||||!|";
	int i = 0;
	char **result = ft_strsplit(s, '|');

	while (result[i])
	{
		if (strcmp(result[i], *expected))
		{
			exit(TEST_FAILED);
		}
		free(result[i]);
		i++;
		expected++;
	}
	free(result);
	exit(TEST_SUCCESS);

Diffs:
    strsplit: |split  |
 ft_strsplit: |split  @|

[fail]: your strsplit does not work with basic input
Test code:
	char *s = "      split       this for   me  !       ";

	char **result = ft_strsplit(s, ' ');
	while (*result)
	{
		if (strcmp(*result, *expected))
		{
			exit(TEST_FAILED);
		}
		result++;
		expected++;
	}
	exit(TEST_SUCCESS);

Diffs:
    strsplit: |split|
 ft_strsplit: ||

ft_itoa:       [OK] [OK] [OK] [OK] [FAILED] [OK] [OK] [OK] [OK] 
[fail]: your itoa don't set \0 at the end of the string
Test code:

	char *i1 = ft_itoa(-1234);
	if (strcmp(i1, "-1234"))
	{
		exit(TEST_FAILED);
	}
	exit(TEST_SUCCESS);

Diffs:
        itoa: |-1234A|
     ft_itoa: |-1234|

ft_putchar:    [OK] [OK] [KO] 
[KO]: your putchar does not work with unicode
Test code:
	char buff[10];
	char buff2[10];
	int c = L'Ã¸';
	int len = 0;

	putwchart(c, &len, buff2);
	buff2[len] = 0;
	fd_to_buffer(1);
	ft_putchar(c);
	write(1, "", 1);
	get_fd_buffer(1, buff, 10);
	if (!strcmp(buff, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
     putchar: |ø|
  ft_putchar: |Ã¸|

ft_putstr:     [OK] [OK] {not protected}
ft_putendl:    [OK] [OK] {not protected}
ft_putnbr:     [OK] [OK] [FAILED] [OK] [FAILED] 
[fail]: your putnbr does not work with int min
Test code:
	int i = (-2147483647 -1);
	char buff[0xF0];

	fd_to_buffer(1);
	ft_putnbr(i);
	write(1, "", 1);
	get_fd_buffer(1, buff, 0xF0);
	if (atoi(buff) == i)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
      putnbr: |-2147483648|
   ft_putnbr: |-8|

[fail]: your putnbr allocate memory, wtf ???
Test code:
	int i = (-2147483647 -1);
	char buff[0xF0];

	fd_to_buffer(1);
	ft_putnbr(i);
	write(1, "", 1);
	get_fd_buffer(1, buff, 0xF0);
	if (atoi(buff) == i)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
      putnbr: |-2147483648|
   ft_putnbr: |-8|

ft_putchar_fd: [OK] [OK] [KO] 
[KO]: your putchar_fd does not work with unicode
Test code:
	char buff[10];
	char buff2[10];
	int c = L'Ã¸';
	int len = 0;

	putwchart(c, &len, buff2);
	buff2[len] = 0;
	fd_to_buffer(2);
	ft_putchar_fd(c, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 10);
	if (!strcmp(buff, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
  putchar_fd: |ø|
ft_putchar_fd: |Ã¸|

ft_putstr_fd:  [OK] [OK] {not protected}
ft_putendl_fd: [OK] [OK] {not protected}
ft_putnbr_fd:  [OK] [OK] [OK] [OK] [FAILED] 
[fail]: your putnbr_fd allocate memory, wtf ???
Test code:
	int i = (-2147483647 -1);
	char buff[0xF0];

	fd_to_buffer(2);
	ft_putnbr_fd(i, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 0xF0);
	if (atoi(buff) == i)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
   putnbr_fd: |-2147483648|
ft_putnbr_fd: |0|

ft_lstnew:     [OK] [OK] [OK] [OK] 
ft_lstdelone:  [OK] 
ft_lstdel:     [OK] [OK] [OK] 
ft_lstadd:     [OK] [OK] [OK] 
ft_lstiter:    [OK] {protected}
ft_lstmap:     [OK] {not protected}
ft_islower:    [OK] 
ft_isupper:    [OK] 
